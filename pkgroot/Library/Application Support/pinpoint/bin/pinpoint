#!/usr/bin/python
# encoding: utf-8
"""
Enables location services (LS),
gives Python access to location services,
and stores the location of your mac to a plist.
More information at https://github.com/clburlison/pinpoint
"""

import os
import plistlib
import platform
import subprocess
import tempfile
import argparse
import logging
import logging.handlers
import json
import sys
from threading import Timer
from urllib2 import urlopen, URLError, HTTPError
from datetime import datetime, timedelta
from time import gmtime, strftime, sleep
from stat import S_IXOTH, S_IWOTH
import objc
import FoundationPlist

# PyLint cannot properly find names inside Cocoa libraries, so issues bogus
# No name 'Foo' in module 'Bar' warnings. Disable them.
# pylint: disable=E0611
from CoreLocation import (CLLocationManager,
                          CLLocation,
                          CLGeocoder,
                          kCLDistanceFilterNone,
                          kCLLocationAccuracyBest)
from Foundation import (NSRunLoop,
                        NSDate,
                        NSObject,
                        NSBundle,
                        CFPreferencesAppSynchronize,
                        CFPreferencesCopyAppValue,
                        CFPreferencesSetValue,
                        kCFPreferencesAnyUser,
                        kCFPreferencesCurrentHost)


__author__ = 'Clayton Burlison (https://clburlison.com)'
__version__ = '1.0.0.58'

# Our preferences "bundle_id"
BUNDLE_ID = 'com.clburlison.pinpoint'

# Disable PyLint variable name checks
# pylint: disable=C0103
# Create global plist object for data storage
plist = dict()


def set_pref(pref_name, pref_value):
    """Sets a preference, writing it to
    /Library/Preferences/com.clburlison.pinpoint.plist.
    This should normally be used only for 'bookkeeping' values;
    values that control the behavior of pinpoint may be overridden
    elsewhere (by MCX, for example)"""
    try:
        CFPreferencesSetValue(
            pref_name, pref_value, BUNDLE_ID,
            kCFPreferencesAnyUser, kCFPreferencesCurrentHost)
        CFPreferencesAppSynchronize(BUNDLE_ID)
    except BaseException:
        pass


def pref(pref_name):
    """Return a preference. Since this uses CFPreferencesCopyAppValue,
    Preferences can be defined several places. Precedence is:
        - MCX/profile
        - /Library/Preferences/com.clburlison.pinpoint.plist
        - default_prefs defined here.
    """
    default_prefs = {
        'AddressLookup': True,
        'AddressLookupService': "apple",
        'CacheDir': '/Library/Application Support/pinpoint',
        'CheckWaitTime': 1800,
        'EnableWireless': False,
        'DisableWireless': False,
    }
    pref_value = CFPreferencesCopyAppValue(pref_name, BUNDLE_ID)
    if pref_value is None:
        pref_value = default_prefs.get(pref_name)
        # we're using a default value. We'll write it out to
        # /Library/Preferences/com.clburlison.pinpoint.plist for admin
        # discoverability
        set_pref(pref_name, pref_value)
    return pref_value


def get_hardware_uuid():
    """Get the UUID of the computer"""
    # IOKit Bundle Objective C code from Michael Lynn
    # https://gist.github.com/pudquick/c7dd1262bd81a32663f0
    uuid = ''
    IOKit_bundle = NSBundle.bundleWithIdentifier_(
        'com.apple.framework.IOKit')
    functions = [("IOServiceGetMatchingService", b"II@"),
                 ("IOServiceMatching", b"@*"),
                 ("IORegistryEntryCreateCFProperty", b"@I@@I"), ]
    IOKit = dict()
    objc.loadBundleFunctions(IOKit_bundle, IOKit, functions)
    # pylint:disable=F0401, E0602, W0232
    uuid = IOKit['IORegistryEntryCreateCFProperty'](
        IOKit['IOServiceGetMatchingService'](
            0, IOKit['IOServiceMatching'](
                'IOPlatformExpertDevice')), 'IOPlatformUUID', None, 0)
    return uuid


def root_check():
    """Check for root access."""
    if not os.geteuid() == 0:
        sys.stderr.write("You must run this as root!")
        exit(1)


def os_vers():
    """Retrieve OS version."""
    maj_os_vers = platform.mac_ver()[0].split('.')[1]
    return maj_os_vers


def os_check():
    """Only tested on 10.8 - 10.11."""
    if not 8 <= int(os_vers()) <= 11:
        status = "Your OS is not supported at this time: %s" % (
            platform.mac_ver()[0])
        logging.warn(status)
        write_to_cache_location(None, status, None)
        exit(0)


def current_time():
    """Prints current date/time stamp"""
    timeFormat = "%Y-%m-%d %H:%M:%S +0000"
    now = strftime(timeFormat, gmtime())
    return now


def check_wait_period(override):
    """Limit the amount of lookups a computer will run.
    We want to use this in conjunction with our LaunchDaemon to
    make sure we always have updated data available without
    going over API limits."""

    # If we pass an override, skip this check
    if override:
        return True

    # Setup and retrive date/time values for checking
    now = convert_date_type(current_time())
    LastCheckDate = pref('LastCheckDate')
    CheckWaitTime = pref('CheckWaitTime')
    last_run_time = convert_date_type(LastCheckDate)

    if CheckWaitTime < 900:
        logging.warn("Your current CheckWaitTime value of %s might not run\n"
                     "as often as you wish due to the LaunchDaemon running"
                     "pinpoint.", CheckWaitTime)

    try:
        future_run_time = last_run_time + timedelta(seconds=CheckWaitTime)
        if now >= future_run_time:
            return True
        else:
            logging.warn("It is not time to run again! Use '-f' "
                         "if you wish to force a lookup.")
            exit(1)
    except TypeError:
        return True


def convert_date_type(strDate):
    """Convert date string type to date type."""
    try:
        return datetime.strptime(strDate, "%Y-%m-%d %H:%M:%S +0000")
    except TypeError:
        pass


def update_check_time():
    """Record last check time"""
    now = current_time()
    logging.debug("Updating 'LastCheckDate' timestamp")
    set_pref('LastCheckDate', now)


def write_to_cache_location(data, status, past_loc):
    """Method to write plist data to disk"""
    global plist
    is_enabled = CLLocationManager.locationServicesEnabled()
    if data is not None:
        plist = data
    if past_loc is not None:
        stale_record = dict(StaleLocation=str('Yes'))
    base_stats = dict(
        CurrentStatus=str(status),
        LastRun=str(current_time()),
        LS_Enabled=bool(is_enabled),
        StaleLocation=str('No'),
    )
    plist.update(base_stats)
    if status != "Successful":
        try:
            logging.debug("Keep past location as we were unable to "
                          "determine your current location")
            plist.update(past_loc)
            plist.update(stale_record)
        except TypeError:
            pass
    output_file = os.path.join(pref('CacheDir'), "location.plist")
    logging.debug("Writing current run details to: %s",
                  output_file)
    plistlib.writePlist(plist, output_file)


def retrieve_past_location():
    """Return the past location from the on disk plist."""
    output_file = os.path.join(pref('CacheDir'), "location.plist")
    logging.debug("Storing past location")
    try:
        on_disk = FoundationPlist.readPlist(output_file)
    except (AttributeError,
            FoundationPlist.NSPropertyListSerializationException):
        on_disk = dict()

    # parse the output to only return the values we want to keep
    try:
        old_location = dict(
            Address=on_disk['Address'],
            Altitude=on_disk['Altitude'],
            GoogleMap=on_disk['GoogleMap'],
            LastLocationRun=on_disk['LastLocationRun'],
            Latitude=on_disk['Latitude'],
            LatitudeAccuracy=on_disk['LatitudeAccuracy'],
            Longitude=on_disk['Longitude'],
            LongitudeAccuracy=on_disk['LongitudeAccuracy'],
        )
    except KeyError:
        old_location = dict()
    return old_location


def service_handler(action):
    """Loads/unloads System's location services launchd job."""
    logging.debug("Currently %sing locationd service", action)
    launchctl = ['/bin/launchctl', action,
                 '/System/Library/LaunchDaemons/com.apple.locationd.plist']
    subprocess.check_output(launchctl)


def sysprefs_boxchk():
    """Enables location services in sysprefs globally."""
    uuid = get_hardware_uuid()
    prefdir = "/private/var/db/locationd/Library/Preferences/ByHost/"
    if not os.path.exists(prefdir):
        logging.debug("Locationd pref directory not present. Creating now.")
        os.makedirs(prefdir)
    das_plist = ("/private/var/db/locationd/Library/Preferences"
                 "/ByHost/com.apple.locationd.{0}.plist".format(uuid.strip()))
    logging.info("Read current locationd settings")
    try:
        on_disk = FoundationPlist.readPlist(das_plist)
    except (AttributeError,
            FoundationPlist.NSPropertyListSerializationException):
        p = {}
        FoundationPlist.writePlist(p, das_plist)
        logging.debug("Creating empty locationd preferences")
        on_disk = FoundationPlist.readPlist(das_plist)
    val = on_disk.get('LocationServicesEnabled', None)
    if val != 1:
        logging.info("Location Services are not enabled")
        service_handler('unload')
        on_disk['LocationServicesEnabled'] = 1
        FoundationPlist.writePlist(on_disk, das_plist)
        os.chown(das_plist, 205, 205)
        service_handler('load')
        logging.info("Location Services have been enabled")
    else:
        logging.info("Location Services are enabled")


def add_python():
    """Python dict for clients.plist in locationd settings."""
    auth_plist = {}
    current_os = int(os_vers())
    domain = 'org.python.python'
    binary_path = ('/System/Library/Frameworks/Python.framework/'
                   'Versions/2.7/Resources/Python.app/Contents/MacOS/Python')

    if current_os == 11:
        domain = "com.apple.locationd.executable-%s" % binary_path

    das_plist = '/private/var/db/locationd/clients.plist'
    try:
        clients_dict = FoundationPlist.readPlist(das_plist)
    except (AttributeError,
            FoundationPlist.NSPropertyListSerializationException):
        p = {}
        FoundationPlist.writePlist(p, das_plist)
        clients_dict = FoundationPlist.readPlist(das_plist)
    val = clients_dict.get(domain, None)
    logging.debug("Current location domain of client.plist is: ")
    logging.debug(val)
    need_to_run = False
    try:
        if val["Authorized"] is not True:
            need_to_run = True
    except TypeError:
        need_to_run = True
    except KeyError:
        need_to_run = True

    # El Capital added a cdhash requirement that is difficult to calculate.
    # As such we are allowing the system to correctly input the values and
    # then giving Python access to LS.
    if need_to_run:
        logging.info("We need to authorize python")
        service_handler('unload')
        clients_dict[domain] = auth_plist
        FoundationPlist.writePlist(clients_dict, das_plist)
        os.chown(das_plist, 205, 205)
        service_handler('load')
        logging.debug("Process a lookup so locationd service can properly "
                      "authorize python for your OS.")
        lookup(1)
        service_handler('unload')
        clients_dict = FoundationPlist.readPlist(das_plist)
        auth_plist = clients_dict[domain]
        auth_plist["Authorized"] = True
        FoundationPlist.writePlist(clients_dict, das_plist)
        os.chown(das_plist, 205, 205)
        service_handler('load')
        clients_dict = FoundationPlist.readPlist(das_plist)
        val = clients_dict.get(domain, None)
        logging.debug("Current location domain of client.plist is now: ")
        logging.debug(val)
        logging.info("Location Services was enabled. "
                     "We are waiting 30 seconds before doing a lookup.")
        sleep(30)
    else:
        logging.info("Python is enabled")


def lookup(time=None):
    """Ask python to find current location."""
    if time == 1:
        # pylint: disable=W0612
        finder = MyLocationManagerDelegate.alloc().init()
        NSRunLoop.currentRunLoop().\
            runUntilDate_(NSDate.dateWithTimeIntervalSinceNow_(time))
    else:
        time = 5
        # Run 3 loops in an attempt to find a location.
        # Each loop increases time by 5 seconds.
        for x in range(3):
            logging.debug("Running lookup loop: %s", x)
            finder = MyLocationManagerDelegate.alloc().init()
            NSRunLoop.currentRunLoop().\
                runUntilDate_(NSDate.dateWithTimeIntervalSinceNow_(time))
            global plist
            try:
                if plist['Latitude'] is not None:
                    break
            except KeyError:
                time += 5


def download_file(url):
    """Download a simple file from the Internet."""
    logging.info("Download file from Google")
    try:
        temp_file = os.path.join(tempfile.mkdtemp(), 'tempdata')
        f = urlopen(url)
        with open(temp_file, "wb") as local_file:
            local_file.write(f.read())
        logging.info("Download successful")
    except HTTPError, e:
        logging.debug("HTTP Error: %s, %s", e.code, url)
    except URLError, e:
        logging.debug("URL Error: %s, %s", e.reason, url)
    try:
        file_handle = open(temp_file)
        data = file_handle.read()
        file_handle.close()
    except (OSError, IOError):
        logging.debug("Couldn't read %s", temp_file)
        return False
    try:
        os.unlink(temp_file)
        os.rmdir(os.path.dirname(temp_file))
    except (OSError, IOError):
        pass
    return data


class script_runner():
    """Functions for running a script safely in the context of root."""
    # Borrowed from Outset - Joe Chilcote
    def check_perms(self, pathname):
        """Check permissions of script before running to verify only root
        has access."""
        mode = os.stat(pathname).st_mode
        owner = os.stat(pathname).st_uid
        if owner == 0 and (mode & S_IXOTH) and not (mode & S_IWOTH):
            return True
        else:
            return False

    def kill_proc(self, proc, timeout):
        """Function to stop processes if they've gone rogue."""
        timeout["value"] = True
        proc.kill()

    def run_script(self, pathname, scripttype, timeout_sec=10):
        """Runs script located at given pathname"""
        if os.path.exists(pathname):
            if self.check_perms(pathname):
                try:
                    proc = subprocess.Popen(pathname,
                                            shell=False,
                                            stdout=subprocess.PIPE,
                                            stderr=subprocess.PIPE)
                    timeout = {"value": False}
                    timer = Timer(timeout_sec, self.kill_proc, [proc, timeout])
                    timer.start()
                    logging.info('Processing %s...', scripttype)
                    (stdout, stderr) = proc.communicate()
                    timer.cancel()
                    if timeout["value"] is True:
                        logging.warn("Script timed out while processing %s",
                                     pathname)
                    if stderr and proc.returncode == 0:
                        logging.info("Output from %s on stderr but it "
                                     "still ran successfully: %s",
                                     pathname, stderr)
                    elif proc.returncode > 0:
                        logging.warn("Failure processing %s: %s",
                                     pathname, stderr)
                    elif proc.returncode == 0:
                        logging.info("Successfully processed %s ", scripttype)
                    return proc.returncode,
                    stdout.decode("utf-8", 'replace'),
                    stderr.decode("utf-8", 'replace'),
                    timeout["value"]
                except (OSError, IOError) as err:
                    logging.warn("Failure processing %s: %s", pathname, err)
                    return False
            else:
                logging.warn("Bad permissions: %s", pathname)
                return False
        else:
            logging.debug("No %s script on disk", scripttype)
            return True


class wireless(object):
    """All functions related to our Mac's wireless."""
    # objc objects do not contain 'members' that Python expect
    # pylint: disable=E1101
    bundle_path = '/System/Library/Frameworks/CoreWLAN.framework'
    IOKit_bundle = NSBundle.bundleWithIdentifier_(
        'com.apple.framework.IOKit')
    functions = [("IOServiceGetMatchingService", b"II@"),
                 ("IOServiceMatching", b"@*"),
                 ("IORegistryEntryCreateCFProperty", b"@I@@I"), ]
    objc.loadBundleFunctions(IOKit_bundle, globals(), functions)
    objc.loadBundle('CoreWLAN',
                    bundle_path=bundle_path,
                    module_globals=globals())

    def mac_has_wireless(self):
        """Check to see if this Mac has a wireless NIC. If it doesn't the
        CoreLocation lookup will fail."""
        iface_name = CWInterface.interfaceNames()
        return True if iface_name else False

    def wireless_status(self):
        """Determine current power state for wireless adapter."""
        iface_name = CWInterface.interfaceNames()
        # This handles a case where we have no wireless interface
        # and the return value is None
        if iface_name:
            # The first interface can be assumed to be the airport card
            iface_name = iface_name.itervalues().next()
            command = ['/usr/sbin/networksetup', '-getairportpower',
                       iface_name]
            proc = subprocess.Popen(command, stdout=subprocess.PIPE)
            wifi_power = (proc.communicate()[0].replace('\n', '')
                          .split(":")[1].replace(' ', ''))
            logging.debug("Wireless interface is currently: %s",
                          wifi_power)
            return wifi_power

    def toggle_wireless(self, value):
        """Toggle the wireless adapter. Takes argument of value as:
        'on' to enable or 'off' to disable wireless.
        Return True if we made a change."""
        wifi_power = self.wireless_status()
        iface = CWInterface.interface()
        value = value.lower()
        if value == "on":
            setPower = True
        if value == "off":
            setPower = False
        if (wifi_power == 'Off' and value == "on") or (
            wifi_power == 'On' and value == "off"
        ):
            iface.setPower_error_(setPower, None)
            logging.debug("Wireless adapter has been turned %s.", value)
            sleep(5)
            return True
        else:
            return False


# Disable PyLints unused argument check as the NSObject
# requires the arguments even if we do not use them.
# pylint: disable=W0613
class MyLocationManagerDelegate(NSObject):
    """CoreLocation delegate for handling location lookups. This class
    is required for python to properly start/stop lookups with location
    services."""
    is_authorized = CLLocationManager.authorizationStatus()
    is_enabled = CLLocationManager.locationServicesEnabled()

    def init(self):
        """Define location manager settings for lookups."""
        self = super(MyLocationManagerDelegate, self).init()
        if not self:
            return
        self.locationManager = CLLocationManager.alloc().init()
        self.locationManager.setDelegate_(self)
        self.locationManager.setDistanceFilter_(kCLDistanceFilterNone)
        self.locationManager.setDesiredAccuracy_(kCLLocationAccuracyBest)
        self.locationManager.startUpdatingLocation()
        return self

    def locationManager_didUpdateToLocation_fromLocation_(self, manager,
                                                          newloc, oldloc):
        """Splits location data into separate pieces for processing later."""
        lat = newloc.coordinate().latitude
        lon = newloc.coordinate().longitude
        verAcc = newloc.verticalAccuracy()
        horAcc = newloc.horizontalAccuracy()
        altitude = newloc.altitude()
        time = newloc.timestamp()
        gmap = (r"http://www.google.com/maps/place/{0},{1},"
                "/@{0},{1},18z/data=!3m1!1e3".format(str(lat), str(lon)))
        logging.info("Process a lookup request")
        global plist
        plist = dict(
            Altitude=int(altitude),
            CurrentStatus=str("Successful"),
            GoogleMap=str(gmap),
            LastLocationRun=str(time),
            Latitude=str(lat),
            LatitudeAccuracy=int(verAcc),
            Longitude=str(lon),
            LongitudeAccuracy=int(horAcc),
        )
        logging.debug("Successful lookup request: %s, %s",
                      plist['Latitude'], plist['Longitude'])

    def locationManager_didFailWithError_(self, manager, err):
        """Handlers errors for location manager."""
        if self.is_enabled is True:
            if self.is_authorized == 3:
                status = "Unable to locate"
            if self.is_authorized == 2:
                status = "Denied"
            if self.is_authorized == 1:
                status = "Restricted"
            if self.is_authorized == 0:
                status = "Not Determined"
        else:
            status = "Location Services Disabled"

        global plist
        plist = dict(CurrentStatus=str("Unsuccessful: " + status))
        logging.info("Lookup request failed")
        logging.debug("Unsuccessful lookup request: %s", status)

# pylint: enable=W0613


class ReverseLookup(object):
    """All functions related to doing a reverse lookup request."""
    # Store our lookup data from Apple's GeoCoder in the following varriable.
    data = None

    def myCompletionHandler(self, placemarks, error):
        """Completion Handler for Apple's GeoCoder."""
        if error is not None:
            # This is an NSError:
            # Error Domain=kCLErrorDomain Code=2 "(null)" - wifi is off
            self.data = str(error)
        elif(placemarks.count() > 0):
            # Placemarks is a CLPlacemark object. Retrieve the data at index 0
            # then the convert the formattedAddressLines, which is an NSArray,
            # into a formated address string.
            addressAsString = ' '.join(placemarks[0].formattedAddressLines())
            self.data = addressAsString
        else:
            self.data = "Unable to retrevie lookup for unknown reason."

    def address_lookup(self, service):
        """Resolve coordinates to a street address."""
        global plist
        api_url = 'https://maps.googleapis.com/maps/api/geocode/json?latlng='
        logging.info("Doing a reverse lookup via: {0}".format(service))
        if pref('AddressLookup'):
            try:
                if plist['Latitude']:
                    lat = plist['Latitude']
                    lon = plist['Longitude']
                    if service == 'google':
                        try:
                            url = '%s%s,%s' % (api_url, lat, lon)
                            data = download_file(url)
                            obj = json.loads(data)
                            address = obj["results"][0]["formatted_address"]
                        except:
                            address = 'Google reverse lookup failed.'
                            logging.warn(address)
                    elif service == 'apple':
                        # We are storing the lat/lon values as strings
                        # and must convert them to float before passing to
                        # Apple's geocoder.
                        location = CLLocation.alloc(
                            ).initWithLatitude_longitude_(
                                float(lat), float(lon))
                        geocoder = CLGeocoder.alloc().init()
                        geocoder.reverseGeocodeLocation_completionHandler_(
                            location, self.myCompletionHandler)
                        NSRunLoop.currentRunLoop().runUntilDate_(
                            NSDate.dateWithTimeIntervalSinceNow_(3))
                        address = (self.data)
                    else:
                        address = ('Unsupported address lookup service: '
                                   '{0}'.format(service))
                        logging.warn(address)
            except KeyError:
                address = 'Unable to determine address'
                logging.warn(address)
        else:
            address = 'Address lookup has been disabled on this computer.'

        # update plist with the address data
        add = dict(Address=address)
        logging.info("Address is: %s", address)
        plist.update(add)


def main():
    """Main method for handling options."""
    parser = argparse.ArgumentParser(prog='pinpoint',
                                     description='This script will attempt to '
                                     'locate your mac.')
    parser.add_argument('--auto', action='store_true', default=True,
                        help='Used by the LaunchDaemon to find your mac in '
                        'the background.')
    parser.add_argument('-v', '--verbose', action='count',
                        help="Increase verbosity level. Repeatable up to"
                        "two times.")
    parser.add_argument('-f', '--force', action='store_true',
                        help='Force the location lookup run disregarding '
                        'last check time.')
    parser.add_argument('-V', '--version', action='store_true',
                        help='Print script version')
    args = parser.parse_args()

    # Verify we are running as root
    root_check()

    # This is the cache directory where we store our found location
    cachedir = pref('CacheDir')
    if not os.path.exists(cachedir):
        os.makedirs(cachedir)

    # Get root logger and set default logging level
    rootLogger = logging.getLogger('')
    rootLogger.setLevel(logging.DEBUG)

    # Write everything to the rotating log file
    log_dir = os.path.join(cachedir, 'Logs')
    if not os.path.exists(log_dir):
        os.mkdir(log_dir)
    log_file = os.path.join(log_dir, 'pinpoint.log')
    log_file_handler = logging.handlers.RotatingFileHandler(
                                filename=log_file,
                                backupCount=3,
                                maxBytes=5242880)
    log_file_format = logging.Formatter(
                                fmt='%(asctime)s [%(levelname)s]: %(message)s',
                                datefmt='%Y-%m-%d %I:%M:%S %p')
    log_file_handler.setFormatter(log_file_format)
    log_file_handler.setLevel(logging.DEBUG)
    rootLogger.addHandler(log_file_handler)

    # Log to the console at a level determined by the --verbose flag
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.CRITICAL)
    console_handler.setFormatter(logging.Formatter(
        '[%(levelname)s]: %(message)s'))
    rootLogger.addHandler(console_handler)

    args = parser.parse_args()
    if not args.verbose:
        console_handler.setLevel('WARNING')
    elif args.verbose == 1:
        console_handler.setLevel('INFO')
    else:
        console_handler.setLevel('DEBUG')

    if args.version:
        print __version__
        exit()

    if args.force:
        override = True
    else:
        override = False

    if args.auto:
        os_check()
        if wireless().mac_has_wireless() is False:
            status = "No wireless interface found."
            write_to_cache_location(None, status, None)
            logging.warn(status)
            exit(0)
        sysprefs_boxchk()
        add_python()
        if check_wait_period(override):
            update_check_time()
            past_loc = retrieve_past_location()
            # Only enable the wireless adapter if the preference key is True
            if pref('EnableWireless'):
                WirelessOutput = wireless().toggle_wireless('on')
            else:
                WirelessOutput = False
            if wireless().wireless_status() == 'Off':
                status = "Wireless interface is turned off."
                write_to_cache_location(None, status, past_loc)
                logging.warn(status)
                exit(0)

            # Run the preflight script if it exists and has good perms
            preflightscript = os.path.join(cachedir, 'preflight')
            result = script_runner().run_script(preflightscript, 'preflight')
            # we ignore the result of the preflight

            lookup()
            service = pref('AddressLookupService')
            ReverseLookup().address_lookup(service)

            try:
                global plist
                status = plist['CurrentStatus']
                write_to_cache_location(plist, status, past_loc)
                logging.info("Current location: %s, %s",
                             plist['Latitude'], plist['Longitude'])
                logging.info("Run status: %s", plist['CurrentStatus'])
            except KeyError:
                status = ("Error obtaining a location. LS was unresponsive "
                          "or a lookup timeout occurred.")
                logging.warn(status)
                write_to_cache_location(plist, status, past_loc)

            # Run the postflight script if it exists and has good perms
            postflightscript = os.path.join(cachedir, 'postflight')
            result = script_runner().run_script(postflightscript, 'postflight')
            # we ignore the result of the postflight

            # Only disable the wireless adapter if the preference key is True
            # and pinpoint earlier enabled wireless
            if pref('DisableWireless'):
                if WirelessOutput:
                    WirelessOutput = wireless().toggle_wireless('off')

if __name__ == '__main__':
    main()
